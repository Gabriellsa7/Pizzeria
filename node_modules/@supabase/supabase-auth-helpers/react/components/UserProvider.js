"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useUser = exports.UserProvider = void 0;
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importStar(require("react"));
var constants_1 = require("../../shared/utils/constants");
var networkRetries = 0;
var refreshTokenTimer;
var UserContext = (0, react_1.createContext)(undefined);
var handleError = function (error) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var err;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                console.log(error);
                if (typeof error.json !== 'function') {
                    return [2 /*return*/, String(error)];
                }
                return [4 /*yield*/, error.json()];
            case 1:
                err = _a.sent();
                return [2 /*return*/, {
                        message: err.msg ||
                            err.message ||
                            err.error_description ||
                            err.error ||
                            JSON.stringify(err),
                        status: (error === null || error === void 0 ? void 0 : error.status) || 500
                    }];
        }
    });
}); };
var userFetcher = function (url) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var response, _a;
    var _b;
    return tslib_1.__generator(this, function (_c) {
        switch (_c.label) {
            case 0: return [4 /*yield*/, fetch(url).catch(function () { return undefined; })];
            case 1:
                response = _c.sent();
                if (!response)
                    return [2 /*return*/, { user: null, accessToken: null, error: 'Request failed' }];
                if (!response.ok) return [3 /*break*/, 2];
                _a = response.json();
                return [3 /*break*/, 4];
            case 2:
                _b = { user: null, accessToken: null };
                return [4 /*yield*/, handleError(response)];
            case 3:
                _a = (_b.error = _c.sent(), _b);
                _c.label = 4;
            case 4: return [2 /*return*/, _a];
        }
    });
}); };
var UserProvider = function (props) {
    var supabaseClient = props.supabaseClient, _a = props.callbackUrl, callbackUrl = _a === void 0 ? '/api/auth/callback' : _a, _b = props.profileUrl, profileUrl = _b === void 0 ? '/api/auth/user' : _b, _c = props.user, initialUser = _c === void 0 ? null : _c, _d = props.fetcher, fetcher = _d === void 0 ? userFetcher : _d, _f = props.autoRefreshToken, autoRefreshToken = _f === void 0 ? true : _f;
    var _g = tslib_1.__read((0, react_1.useState)(initialUser), 2), user = _g[0], setUser = _g[1];
    var _h = tslib_1.__read((0, react_1.useState)(null), 2), accessToken = _h[0], setAccessToken = _h[1];
    var _j = tslib_1.__read((0, react_1.useState)(!initialUser), 2), isLoading = _j[0], setIsLoading = _j[1];
    var _k = tslib_1.__read((0, react_1.useState)(), 2), error = _k[0], setError = _k[1];
    var checkSession = (0, react_1.useCallback)(function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        var _a, user_1, accessToken_1, error_1, expiresAt, timeout, timeNow, expiresIn, refreshDurationBeforeExpires, _e_1, error_2;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 2, , 3]);
                    networkRetries++;
                    return [4 /*yield*/, fetcher(profileUrl)];
                case 1:
                    _a = _b.sent(), user_1 = _a.user, accessToken_1 = _a.accessToken, error_1 = _a.error;
                    if (error_1) {
                        if (error_1 === 'Request failed' && networkRetries < constants_1.MAX_RETRIES) {
                            if (refreshTokenTimer)
                                clearTimeout(refreshTokenTimer);
                            refreshTokenTimer = setTimeout(checkSession, Math.pow(constants_1.RETRY_INTERVAL, networkRetries) * 100 // exponential backoff
                            );
                            return [2 /*return*/];
                        }
                        console.error(error_1);
                        setError(new Error(error_1));
                    }
                    networkRetries = 0;
                    if (accessToken_1) {
                        supabaseClient.auth.setAuth(accessToken_1);
                        setAccessToken(accessToken_1);
                    }
                    setUser(user_1);
                    // Set up auto token refresh
                    if (autoRefreshToken) {
                        expiresAt = user_1.exp;
                        timeout = 20 * 1000;
                        if (expiresAt) {
                            timeNow = Math.round(Date.now() / 1000);
                            expiresIn = expiresAt - timeNow;
                            refreshDurationBeforeExpires = expiresIn > constants_1.TOKEN_REFRESH_MARGIN ? constants_1.TOKEN_REFRESH_MARGIN : 0.5;
                            timeout = (expiresIn - refreshDurationBeforeExpires) * 1000;
                        }
                        setTimeout(checkSession, timeout);
                    }
                    if (!user_1)
                        setIsLoading(false);
                    return [3 /*break*/, 3];
                case 2:
                    _e_1 = _b.sent();
                    error_2 = new Error("The request to ".concat(profileUrl, " failed"));
                    setError(error_2);
                    return [3 /*break*/, 3];
                case 3: return [2 /*return*/];
            }
        });
    }); }, [profileUrl]);
    var handleVisibilityChange = function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!((document === null || document === void 0 ? void 0 : document.visibilityState) === 'visible')) return [3 /*break*/, 2];
                    setIsLoading(true);
                    return [4 /*yield*/, checkSession()];
                case 1:
                    _a.sent();
                    setIsLoading(false);
                    _a.label = 2;
                case 2: return [2 /*return*/];
            }
        });
    }); };
    (0, react_1.useEffect)(function () {
        handleVisibilityChange();
        if (autoRefreshToken)
            window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', handleVisibilityChange);
        var authListener = supabaseClient.auth.onAuthStateChange(function (event, session) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (event === 'TOKEN_REFRESHED')
                            return [2 /*return*/]; // ignore this as we're refreshing tokens server-side.
                        setIsLoading(true);
                        // Forward session from client to server where it is set in a Cookie.
                        // NOTE: this will eventually be removed when the Cookie can be set differently.
                        return [4 /*yield*/, fetch(callbackUrl, {
                                method: 'POST',
                                headers: new Headers({ 'Content-Type': 'application/json' }),
                                credentials: 'same-origin',
                                body: JSON.stringify({ event: event, session: session })
                            }).then(function (res) {
                                if (!res.ok) {
                                    var error_3 = new Error("The request to ".concat(callbackUrl, " failed"));
                                    setError(error_3);
                                }
                            })];
                    case 1:
                        // Forward session from client to server where it is set in a Cookie.
                        // NOTE: this will eventually be removed when the Cookie can be set differently.
                        _a.sent();
                        // Fetch the user from the API route
                        return [4 /*yield*/, checkSession()];
                    case 2:
                        // Fetch the user from the API route
                        _a.sent();
                        setIsLoading(false);
                        return [2 /*return*/];
                }
            });
        }); }).data;
        return function () {
            window === null || window === void 0 ? void 0 : window.removeEventListener('visibilitychange', handleVisibilityChange);
            authListener === null || authListener === void 0 ? void 0 : authListener.unsubscribe();
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    var value = {
        isLoading: isLoading,
        user: user,
        accessToken: accessToken,
        error: error,
        checkSession: checkSession
    };
    return react_1.default.createElement(UserContext.Provider, tslib_1.__assign({ value: value }, props));
};
exports.UserProvider = UserProvider;
var useUser = function () {
    var context = (0, react_1.useContext)(UserContext);
    if (context === undefined) {
        throw new Error("useUser must be used within a UserProvider.");
    }
    return context;
};
exports.useUser = useUser;
//# sourceMappingURL=UserProvider.js.map