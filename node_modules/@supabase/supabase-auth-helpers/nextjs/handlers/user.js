"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var jwt_1 = require("../../shared/utils/jwt");
var getUser_1 = tslib_1.__importDefault(require("../utils/getUser"));
var constants_1 = require("../../shared/utils/constants");
function handleUser(req, res, options) {
    var _a;
    if (options === void 0) { options = {}; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var cookieOptions, tokenRefreshMargin, access_token, jwtUser, timeNow, response, user, mergedUser, e_1, error;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 4, , 5]);
                    if (!req.cookies) {
                        throw new Error('Not able to parse cookies!');
                    }
                    cookieOptions = tslib_1.__assign(tslib_1.__assign({}, constants_1.COOKIE_OPTIONS), options.cookieOptions);
                    tokenRefreshMargin = (_a = options.tokenRefreshMargin) !== null && _a !== void 0 ? _a : constants_1.TOKEN_REFRESH_MARGIN;
                    access_token = req.cookies["".concat(cookieOptions.name, "-access-token")];
                    if (!access_token) {
                        throw new Error('No cookie found!');
                    }
                    jwtUser = (0, jwt_1.jwtDecoder)(access_token);
                    if (!(jwtUser === null || jwtUser === void 0 ? void 0 : jwtUser.exp)) {
                        throw new Error('Not able to parse JWT payload!');
                    }
                    timeNow = Math.round(Date.now() / 1000);
                    if (!(jwtUser.exp < timeNow + tokenRefreshMargin)) return [3 /*break*/, 2];
                    return [4 /*yield*/, (0, getUser_1.default)({ req: req, res: res }, { cookieOptions: cookieOptions, tokenRefreshMargin: tokenRefreshMargin })];
                case 1:
                    response = _b.sent();
                    res.status(200).json(response);
                    return [3 /*break*/, 3];
                case 2:
                    user = {
                        id: jwtUser.sub,
                        aud: null,
                        role: null,
                        email: null,
                        email_confirmed_at: null,
                        phone: null,
                        confirmed_at: null,
                        last_sign_in_at: null,
                        app_metadata: {},
                        user_metadata: {},
                        identities: [],
                        created_at: null,
                        updated_at: null,
                        'supabase-auth-helpers-note': 'This user payload is retrieved from the cached JWT and might be stale. If you need up to date user data, please call the `getUser` method in a server-side context!'
                    };
                    mergedUser = tslib_1.__assign(tslib_1.__assign({}, user), jwtUser);
                    res.status(200).json({ user: mergedUser, accessToken: access_token });
                    _b.label = 3;
                case 3: return [3 /*break*/, 5];
                case 4:
                    e_1 = _b.sent();
                    error = e_1;
                    res
                        .status(200)
                        .json({ user: null, accessToken: null, error: error.message });
                    return [3 /*break*/, 5];
                case 5: return [2 /*return*/];
            }
        });
    });
}
exports.default = handleUser;
//# sourceMappingURL=user.js.map