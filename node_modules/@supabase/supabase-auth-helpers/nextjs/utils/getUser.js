"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var supabase_js_1 = require("@supabase/supabase-js");
var cookies_1 = require("../../shared/utils/cookies");
var constants_1 = require("../../shared/utils/constants");
var jwt_1 = require("../../shared/utils/jwt");
var NextAdapter_1 = require("../../shared/adapters/NextAdapter");
function getUser(context, options) {
    var _a;
    if (options === void 0) { options = { forceRefresh: false }; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var supabase, cookieOptions_1, tokenRefreshMargin, access_token, refresh_token, jwtUser, timeNow, _b, data, error, _c, user, getUserError, e_1, error;
        return tslib_1.__generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    _d.trys.push([0, 5, , 6]);
                    if (!process.env.NEXT_PUBLIC_SUPABASE_URL ||
                        !process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY) {
                        throw new Error('NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY env variables are required!');
                    }
                    if (!context.req.cookies) {
                        throw new Error('Not able to parse cookies!');
                    }
                    supabase = (0, supabase_js_1.createClient)(process.env.NEXT_PUBLIC_SUPABASE_URL, process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY);
                    cookieOptions_1 = tslib_1.__assign(tslib_1.__assign({}, constants_1.COOKIE_OPTIONS), options.cookieOptions);
                    tokenRefreshMargin = (_a = options.tokenRefreshMargin) !== null && _a !== void 0 ? _a : constants_1.TOKEN_REFRESH_MARGIN;
                    access_token = context.req.cookies["".concat(cookieOptions_1.name, "-access-token")];
                    refresh_token = context.req.cookies["".concat(cookieOptions_1.name, "-refresh-token")];
                    if (!access_token) {
                        throw new Error('No cookie found!');
                    }
                    jwtUser = (0, jwt_1.jwtDecoder)(access_token);
                    if (!(jwtUser === null || jwtUser === void 0 ? void 0 : jwtUser.exp)) {
                        throw new Error('Not able to parse JWT payload!');
                    }
                    timeNow = Math.round(Date.now() / 1000);
                    if (!(options.forceRefresh || jwtUser.exp < timeNow + tokenRefreshMargin)) return [3 /*break*/, 2];
                    // JWT is expired, let's refresh from Gotrue
                    if (!refresh_token)
                        throw new Error('No refresh_token cookie found!');
                    return [4 /*yield*/, supabase.auth.api.refreshAccessToken(refresh_token)];
                case 1:
                    _b = _d.sent(), data = _b.data, error = _b.error;
                    if (error) {
                        throw error;
                    }
                    else {
                        (0, cookies_1.setCookies)(new NextAdapter_1.NextRequestAdapter(context.req), new NextAdapter_1.NextResponseAdapter(context.res), [
                            { key: 'access-token', value: data.access_token },
                            { key: 'refresh-token', value: data.refresh_token }
                        ].map(function (token) {
                            var _a;
                            return ({
                                name: "".concat(cookieOptions_1.name, "-").concat(token.key),
                                value: token.value,
                                domain: cookieOptions_1.domain,
                                maxAge: (_a = cookieOptions_1.lifetime) !== null && _a !== void 0 ? _a : 0,
                                path: cookieOptions_1.path,
                                sameSite: cookieOptions_1.sameSite
                            });
                        }));
                        return [2 /*return*/, { user: data.user, accessToken: data.access_token }];
                    }
                    return [3 /*break*/, 4];
                case 2: return [4 /*yield*/, supabase.auth.api.getUser(access_token)];
                case 3:
                    _c = _d.sent(), user = _c.user, getUserError = _c.error;
                    if (getUserError) {
                        throw getUserError;
                    }
                    return [2 /*return*/, { user: user, accessToken: access_token }];
                case 4: return [3 /*break*/, 6];
                case 5:
                    e_1 = _d.sent();
                    error = e_1;
                    console.log('Error getting user:', error);
                    return [2 /*return*/, { user: null, accessToken: null, error: error.message }];
                case 6: return [2 /*return*/];
            }
        });
    });
}
exports.default = getUser;
//# sourceMappingURL=getUser.js.map