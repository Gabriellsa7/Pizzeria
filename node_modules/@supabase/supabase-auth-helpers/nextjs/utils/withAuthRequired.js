"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var jwt_1 = require("../../shared/utils/jwt");
var constants_1 = require("../../shared/utils/constants");
var getAccessToken_1 = tslib_1.__importDefault(require("./getAccessToken"));
var getUser_1 = tslib_1.__importDefault(require("./getUser"));
/**
 * @deprecated use `withPageAuth` instead!
 * ## Protecting Pages with Server Side Rendering (SSR)
 * If you wrap your `getServerSideProps` with {@link withAuthRequired} your props object will be augmented with
 * the user object {@link User}
 *
 * ```js
 * // pages/profile.js
 * import { withAuthRequired } from '@supabase/supabase-auth-helpers/nextjs';
 *
 * export default function Profile({ user }) {
 *   return <div>Hello {user.name}</div>;
 * }
 *
 * export const getServerSideProps = withAuthRequired({ redirectTo: '/login' });
 * ```
 *
 * If there is no authenticated user, they will be redirect to your home page, unless you specify the `redirectTo` option.
 *
 * You can pass in your own `getServerSideProps` method, the props returned from this will be merged with the
 * user props. You can also access the user session data by calling `getUser` inside of this method, eg:
 *
 * ```js
 * // pages/protected-page.js
 * import { withAuthRequired, getUser } from '@supabase/supabase-auth-helpers/nextjs';
 *
 * export default function ProtectedPage({ user, customProp }) {
 *   return <div>Protected content</div>;
 * }
 *
 * export const getServerSideProps = withAuthRequired({
 *   redirectTo: '/foo',
 *   async getServerSideProps(ctx) {
 *     // Run queries with RLS on the server
 *     const { data } = await supabaseServerClient(ctx).from('test').select('*');
 *     return { props: { data } };
 *   }
 * });
 * ```
 *
 * @deprecated use `withApiAuth` instead!
 * ## Protecting API routes
 * Wrap an API Route to check that the user has a valid session. If they're not logged in the handler will return a
 * 401 Unauthorized.
 *
 * ```js
 * // pages/api/protected-route.js
 * import { withAuthRequired, supabaseServerClient } from '@supabase/supabase-auth-helpers/nextjs';
 *
 * export default withAuthRequired(async function ProtectedRoute(req, res) {
 *   // Run queries with RLS on the server
 *   const { data } = await supabaseServerClient({ req, res }).from('test').select('*');
 *   res.json(data)
 * });
 * ```
 *
 * If you visit `/api/protected-route` without a valid session cookie, you will get a 401 response.
 *
 * @category Server
 */
function withAuthRequired(arg, options) {
    var _this = this;
    if (options === void 0) { options = {}; }
    if (typeof arg === 'function') {
        return function (req, res) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var cookieOptions, accessToken, error_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 3, , 4]);
                        cookieOptions = tslib_1.__assign(tslib_1.__assign({}, constants_1.COOKIE_OPTIONS), options.cookieOptions);
                        return [4 /*yield*/, (0, getAccessToken_1.default)({ req: req, res: res }, { cookieOptions: cookieOptions })];
                    case 1:
                        accessToken = _a.sent();
                        if (!accessToken)
                            throw new Error('No access token!');
                        return [4 /*yield*/, arg(req, res)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        error_1 = _a.sent();
                        res.status(401).json({
                            error: 'not_authenticated',
                            description: 'The user does not have an active session or is not authenticated'
                        });
                        return [2 /*return*/];
                    case 4: return [2 /*return*/];
                }
            });
        }); };
    }
    else {
        var _a = arg ? arg : {}, _b = _a.getServerSideProps, getServerSideProps_1 = _b === void 0 ? undefined : _b, _c = _a.redirectTo, redirectTo_1 = _c === void 0 ? '/' : _c, _d = _a.cookieOptions, cookieOptions_1 = _d === void 0 ? {} : _d;
        return function (context) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var access_token, user, accessToken, jwtUser, timeNow, response, mergedUser, ret, e_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 6, , 7]);
                        if (!context.req.cookies) {
                            throw new Error('Not able to parse cookies!');
                        }
                        cookieOptions_1 = tslib_1.__assign(tslib_1.__assign({}, constants_1.COOKIE_OPTIONS), cookieOptions_1);
                        access_token = context.req.cookies["".concat(cookieOptions_1.name, "-access-token")];
                        if (!access_token) {
                            throw new Error('No cookie found!');
                        }
                        user = void 0, accessToken = void 0;
                        jwtUser = (0, jwt_1.jwtDecoder)(access_token);
                        if (!(jwtUser === null || jwtUser === void 0 ? void 0 : jwtUser.exp)) {
                            throw new Error('Not able to parse JWT payload!');
                        }
                        timeNow = Math.round(Date.now() / 1000);
                        if (!(jwtUser.exp < timeNow)) return [3 /*break*/, 2];
                        return [4 /*yield*/, (0, getUser_1.default)(context, { cookieOptions: cookieOptions_1 })];
                    case 1:
                        response = _a.sent();
                        user = response.user;
                        accessToken = response.accessToken;
                        return [3 /*break*/, 3];
                    case 2:
                        // Transform JWT and add note that it ise cached from JWT.
                        user = {
                            id: jwtUser.sub,
                            aud: null,
                            role: null,
                            email: null,
                            email_confirmed_at: null,
                            phone: null,
                            confirmed_at: null,
                            last_sign_in_at: null,
                            app_metadata: {},
                            user_metadata: {},
                            identities: [],
                            created_at: null,
                            updated_at: null,
                            'supabase-auth-helpers-note': 'This user payload is retrieved from the cached JWT and might be stale. If you need up to date user data, please call the `getUser` method in a server-side context!'
                        };
                        mergedUser = tslib_1.__assign(tslib_1.__assign({}, user), jwtUser);
                        user = mergedUser;
                        accessToken = access_token;
                        _a.label = 3;
                    case 3:
                        if (!user) {
                            throw new Error('No user found!');
                        }
                        ret = { props: {} };
                        if (!getServerSideProps_1) return [3 /*break*/, 5];
                        return [4 /*yield*/, getServerSideProps_1(context)];
                    case 4:
                        ret = _a.sent();
                        _a.label = 5;
                    case 5: return [2 /*return*/, tslib_1.__assign(tslib_1.__assign({}, ret), { props: tslib_1.__assign(tslib_1.__assign({}, ret.props), { user: user, accessToken: accessToken }) })];
                    case 6:
                        e_1 = _a.sent();
                        return [2 /*return*/, {
                                redirect: {
                                    destination: redirectTo_1,
                                    permanent: false
                                }
                            }];
                    case 7: return [2 /*return*/];
                }
            });
        }); };
    }
}
exports.default = withAuthRequired;
//# sourceMappingURL=withAuthRequired.js.map